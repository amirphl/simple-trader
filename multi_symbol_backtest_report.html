<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Symbol Backtest Results</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #666;
        }
        .error {
            text-align: center;
            padding: 50px;
            color: #dc3545;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 5px;
            margin: 20px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        .positive { color: #28a745; }
        .negative { color: #dc3545; }
        .symbol-grid {
            display: flex;
            flex-direction: column;
            gap: 30px;
            padding: 30px;
        }
        .symbol-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        .symbol-header {
            background: #343a40;
            color: white;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.1em;
        }
        .symbol-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            padding: 20px;
            background: #f8f9fa;
        }
        .symbol-stat {
            text-align: center;
        }
        .symbol-stat-value {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .symbol-stat-label {
            font-size: 0.8em;
            color: #666;
        }
        .charts-container {
            padding: 20px;
        }
        .chart-container {
            margin-bottom: 20px;
        }
        .chart-container h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            text-align: center;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
        }
        .heikin-ashi-container {
            border-top: 2px solid #dee2e6;
            padding-top: 20px;
        }
        .stochastic-container {
            border-top: 2px solid #dee2e6;
            padding-top: 20px;
        }
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .stochastic-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        .stoch-button {
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .stoch-button.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .stoch-button:hover {
            background: #e9ecef;
        }
        .stoch-button.active:hover {
            background: #0056b3;
        }
        .control-group label {
            font-weight: 500;
        }
        .all-symbols-performance {
            padding: 30px;
            background: white;
        }
        .performance-table-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin-top: 20px;
        }
        .performance-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .performance-table th,
        .performance-table td {
            padding: 12px 8px;
            text-align: right;
            border-bottom: 1px solid #eee;
        }
        .performance-table th {
            background-color: #f8f9fa;
            font-weight: bold;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .performance-table th:first-child,
        .performance-table td:first-child {
            text-align: center;
            font-weight: bold;
        }
        .performance-table th:nth-child(2),
        .performance-table td:nth-child(2) {
            text-align: left;
            font-weight: bold;
        }
        .performance-table tr:hover {
            background-color: #f8f9fa;
        }
        .performance-table tr:nth-child(even) {
            background-color: #fafafa;
        }
        .performance-table tr:nth-child(even):hover {
            background-color: #f0f0f0;
        }
        .performance-summary {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .summary-stat {
            background: white;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .summary-stat-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .summary-stat-label {
            font-size: 0.9em;
            color: #666;
        }
        .symbol-selector-section {
            padding: 30px;
            background: white;
            border-bottom: 1px solid #eee;
        }
        .symbol-selector-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        .symbol-selector {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            min-width: 200px;
            background: white;
        }
        .symbol-selector:focus {
            outline: none;
            border-color: #007bff;
        }
        .load-chart-btn {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .load-chart-btn:hover:not(:disabled) {
            background: #0056b3;
        }
        .load-chart-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .selected-symbol-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .selected-symbol-info h3 {
            margin-top: 0;
            color: #333;
        }
        .selected-symbol-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .selected-symbol-stat {
            background: white;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .selected-symbol-stat-value {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .selected-symbol-stat-label {
            font-size: 0.8em;
            color: #666;
        }
        .refresh-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px;
        }
        .refresh-btn:hover {
            background: #0056b3;
        }
        
        /* Tooltip styles */
        .tooltip {
            position: fixed;
            background: #ffffff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            font-size: 13px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            z-index: 10000;
            display: none;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
            left: 20px !important;
            top: 20px !important;
        }
        .tooltip table {
            width: 100%;
            border-collapse: collapse;
        }
        .tooltip th, .tooltip td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .tooltip th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        .tooltip .close-btn {
            position: absolute;
            top: 5px;
            right: 8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Multi-Symbol Backtest Results</h1>
            <div id="strategy-info"></div>
        </div>
        
        <button class="refresh-btn" onclick="loadData()">Refresh Data</button>
        
        <div id="loading" class="loading">
            Loading backtest data...
        </div>
        
        <div id="error-message" class="error" style="display: none;">
        </div>
        
        <div id="content" style="display: none;">
            <div id="stats-grid" class="stats-grid">
                <!-- Stats will be populated here -->
            </div>
            
            <div class="symbol-selector-section">
                <h2>Symbol Chart Analysis</h2>
                <div class="symbol-selector-container">
                    <label for="symbol-selector">Select Symbol:</label>
                    <select id="symbol-selector" class="symbol-selector">
                        <option value="">Choose a symbol...</option>
                    </select>
                    <button id="load-chart-btn" class="load-chart-btn" onclick="loadSelectedSymbolChart()" disabled>
                        Load Chart
                    </button>
                </div>
                <div id="selected-symbol-info" class="selected-symbol-info" style="display: none;">
                    <!-- Selected symbol info will be populated here -->
                </div>
            </div>
            
            <div id="symbol-grid" class="symbol-grid">
                <!-- Symbol charts will be populated here -->
            </div>
            
            <div class="all-symbols-performance">
                <h2>All Symbols Performance</h2>
                <div id="performance-summary" class="performance-summary">
                    <!-- Performance summary will be populated here -->
                </div>
                <div class="performance-table-container">
                    <table id="all-symbols-table" class="performance-table">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Symbol</th>
                                <th>Starting Balance</th>
                                <th>Ending Balance</th>
                                <th>PnL</th>
                                <th>PnL %</th>
                                <th>Trades</th>
                                <th>Wins</th>
                                <th>Losses</th>
                                <th>Win Rate</th>
                                <th>Max Drawdown</th>
                                <th>Max Drawdown %</th>
                                <th>Max Equity</th>
                            </tr>
                        </thead>
                        <tbody id="all-symbols-tbody">
                            <!-- All symbols will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip for candle details -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        let backtestData = null;
        let charts = {};
        let stochasticSeries = {};

        // Helper function to get CSS class based on value comparison
        function getClass(value, threshold) {
            return value >= threshold ? 'positive' : 'negative';
        }

        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', { 
                style: 'currency', 
                currency: 'USD' 
            }).format(value);
        }

        // Helper function to format percentage
        function formatPercentage(value) {
            return (value * 100).toFixed(2) + '%';
        }

        // Load data from JSON file
        async function loadData() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error-message');
            const contentEl = document.getElementById('content');
            
            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            contentEl.style.display = 'none';

            try {
                const response = await fetch('multi_symbol_backtest_data.json?' + Date.now()); // Cache busting
                if (!response.ok) {
                    throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);
                }
                
                backtestData = await response.json();
                console.log('Loaded backtest data:', backtestData);
                
                // Validate the structure of loaded data
                if (!backtestData || typeof backtestData !== 'object') {
                    throw new Error('Invalid JSON structure: root object is missing');
                }
                
                if (!backtestData.results) {
                    throw new Error('Invalid JSON structure: "results" property is missing');
                }
                
                if (!backtestData.results.results) {
                    throw new Error('Invalid JSON structure: "results.results" property is missing');
                }
                
                console.log('Chart data loaded - symbols:', backtestData.chartData ? backtestData.chartData.length : 0);
                
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';
                
                // Populate the UI
                populateHeader();
                populateStats();
                populateSymbolCharts();
                populatePerformanceSummary();
                
            } catch (error) {
                console.error('Error loading data:', error);
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
                errorEl.innerHTML = `
                    <h3>Failed to Load Data</h3>
                    <p>${error.message}</p>
                    <p>Please ensure the <code>multi_symbol_backtest_data.json</code> file exists and run the backtest to generate it.</p>
                    <button onclick="loadData()" style="margin-top: 10px; padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Retry</button>
                `;
            }
        }

        // Populate header information
        function populateHeader() {
            const results = backtestData.results;
            const strategyInfo = document.getElementById('strategy-info');
            
            const startTime = new Date(results.start_time).toLocaleDateString();
            const endTime = new Date(results.end_time).toLocaleDateString();
            const duration = Math.round((new Date(results.end_time) - new Date(results.start_time)) / (1000 * 60 * 60)); // hours
            
            strategyInfo.innerHTML = `
                <h2>${results.strategy} Strategy</h2>
                <p>Period: ${startTime} to ${endTime} | Duration: ${duration}h</p>
            `;
        }

        // Populate statistics grid
        function populateStats() {
            const results = backtestData.results;
            const metrics = results.overall_metrics;
            const statsGrid = document.getElementById('stats-grid');
            
            const stats = [
                {
                    value: results.total_symbols,
                    label: 'Total Symbols',
                    class: ''
                },
                {
                    value: results.successful_runs,
                    label: 'Successful Runs',
                    class: ''
                },
                {
                    value: Math.round(metrics.total_trades || 0),
                    label: 'Total Trades',
                    class: ''
                },
                {
                    value: formatPercentage(metrics.overall_win_rate || 0),
                    label: 'Overall Win Rate',
                    class: getClass((metrics.overall_win_rate || 0) * 100, 50)
                },
                {
                    value: formatCurrency(metrics.total_pnl || 0),
                    label: 'Total P&L',
                    class: getClass(metrics.total_pnl || 0, 0)
                },
                {
                    value: formatCurrency(metrics.avg_pnl_per_symbol || 0),
                    label: 'Avg P&L per Symbol',
                    class: getClass(metrics.avg_pnl_per_symbol || 0, 0)
                },
                {
                    value: `${Math.round(metrics.profitable_symbols_count || 0)}/${results.successful_runs}`,
                    label: 'Profitable Symbols',
                    class: ''
                },
                {
                    value: formatPercentage(metrics.profitable_symbols_ratio || 0),
                    label: 'Success Rate',
                    class: getClass((metrics.profitable_symbols_ratio || 0) * 100, 50)
                }
            ];

            statsGrid.innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-value ${stat.class}">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                </div>
            `).join('');
        }

        // Populate symbol selector
        function populateSymbolCharts() {
            const results = backtestData.results.results;
            const symbolSelector = document.getElementById('symbol-selector');
            const loadChartBtn = document.getElementById('load-chart-btn');
            
            // Check if we have valid data
            if (!results || typeof results !== 'object') {
                console.error('No valid results data found');
                return;
            }
            
            // Clear existing options
            symbolSelector.innerHTML = '<option value="">Choose a symbol...</option>';
            
            // Sort symbols by PnL for better UX
            const sortedSymbols = Object.entries(results).sort((a, b) => {
                const pnlA = a[1].equity - a[1].starting_balance;
                const pnlB = b[1].equity - b[1].starting_balance;
                return pnlB - pnlA; // Sort by PnL descending
            });
            
            // Add options to selector
            sortedSymbols.forEach(([symbol, result]) => {
                const pnl = result.equity - result.starting_balance;
                const pnlClass = getClass(pnl, 0);
                const option = document.createElement('option');
                option.value = symbol;
                option.innerHTML = `${symbol} (${formatCurrency(pnl)})`;
                option.className = pnlClass;
                symbolSelector.appendChild(option);
            });
            
            // Enable the load chart button
            loadChartBtn.disabled = false;
            
            // Add event listener to symbol selector
            symbolSelector.addEventListener('change', function() {
                const selectedSymbol = this.value;
                if (selectedSymbol) {
                    showSelectedSymbolInfo(selectedSymbol);
                    loadChartBtn.disabled = false;
                } else {
                    hideSelectedSymbolInfo();
                    loadChartBtn.disabled = true;
                }
            });
        }
        
        // Show selected symbol information
        function showSelectedSymbolInfo(symbol) {
            const results = backtestData.results.results;
            const result = results[symbol];
            const infoContainer = document.getElementById('selected-symbol-info');
            
            if (!result) {
                console.error(`No data found for symbol: ${symbol}`);
                return;
            }
            
            const pnl = result.equity - result.starting_balance;
            const pnlPercentage = ((result.equity - result.starting_balance) / result.starting_balance) * 100;
            const winRate = result.trades > 0 ? (result.wins / result.trades) * 100 : 0;
            const maxDrawdownPercentage = (result.max_drawdown / result.starting_balance) * 100;
            
            infoContainer.innerHTML = `
                <h3>${symbol} - Performance Summary</h3>
                <div class="selected-symbol-stats">
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value ${getClass(pnl, 0)}">${formatCurrency(pnl)}</div>
                        <div class="selected-symbol-stat-label">Total PnL</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value ${getClass(pnlPercentage, 0)}">${pnlPercentage.toFixed(2)}%</div>
                        <div class="selected-symbol-stat-label">PnL %</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value">${result.trades}</div>
                        <div class="selected-symbol-stat-label">Total Trades</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value">${result.wins}</div>
                        <div class="selected-symbol-stat-label">Wins</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value">${result.losses}</div>
                        <div class="selected-symbol-stat-label">Losses</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value ${getClass(winRate, 50)}">${winRate.toFixed(1)}%</div>
                        <div class="selected-symbol-stat-label">Win Rate</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value">${formatCurrency(result.max_drawdown)}</div>
                        <div class="selected-symbol-stat-label">Max Drawdown</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value">${maxDrawdownPercentage.toFixed(2)}%</div>
                        <div class="selected-symbol-stat-label">Max Drawdown %</div>
                    </div>
                    <div class="selected-symbol-stat">
                        <div class="selected-symbol-stat-value">${formatCurrency(result.max_equity)}</div>
                        <div class="selected-symbol-stat-label">Max Equity</div>
                    </div>
                </div>
            `;
            
            infoContainer.style.display = 'block';
        }
        
        // Hide selected symbol information
        function hideSelectedSymbolInfo() {
            const infoContainer = document.getElementById('selected-symbol-info');
            infoContainer.style.display = 'none';
        }
        
        // Load chart for selected symbol
        function loadSelectedSymbolChart() {
            const selectedSymbol = document.getElementById('symbol-selector').value;
            if (!selectedSymbol) {
                alert('Please select a symbol first.');
                return;
            }
            
            const chartData = backtestData.chartData;
            if (!chartData || !Array.isArray(chartData)) {
                alert('No chart data available for the selected symbol.');
                return;
            }
            
            // Clear existing charts
            const symbolGrid = document.getElementById('symbol-grid');
            symbolGrid.innerHTML = '';
            
            // Create chart for selected symbol
            createSelectedSymbolChart(selectedSymbol, chartData);
        }
        
        // Create chart for selected symbol
        function createSelectedSymbolChart(symbol, allChartData) {
            const symbolGrid = document.getElementById('symbol-grid');
            const results = backtestData.results.results;
            const result = results[symbol];
            
            if (!result) {
                console.error(`No data found for symbol: ${symbol}`);
                return;
            }
            
            const pnl = result.equity - result.starting_balance;
            const winRate = result.trades > 0 ? (result.wins / result.trades) * 100 : 0;
            
            // Create symbol card
            const symbolCard = document.createElement('div');
            symbolCard.className = 'symbol-card';
            symbolCard.innerHTML = `
                <div class="symbol-header">${symbol}</div>
                <div class="symbol-stats">
                    <div class="symbol-stat">
                        <div class="symbol-stat-value ${getClass(pnl, 0)}">${formatCurrency(pnl)}</div>
                        <div class="symbol-stat-label">P&L</div>
                    </div>
                    <div class="symbol-stat">
                        <div class="symbol-stat-value">${result.trades}</div>
                        <div class="symbol-stat-label">Trades</div>
                    </div>
                    <div class="symbol-stat">
                        <div class="symbol-stat-value ${getClass(winRate, 50)}">${winRate.toFixed(1)}%</div>
                        <div class="symbol-stat-label">Win Rate</div>
                    </div>
                </div>
                <div class="charts-container">
                    <div class="chart-container">
                        <h4>Regular Candles</h4>
                        <div id="chart-selected" style="height: 400px;"></div>
                    </div>
                    <div class="chart-container stochastic-container" id="stochastic-container-selected">
                        <h4>Stochastic Oscillator</h4>
                        <div id="stochastic-chart-selected" style="height: 250px;"></div>
                    </div>
                    <div class="chart-container heikin-ashi-container" id="heikin-ashi-container-selected">
                        <h4>Heikin Ashi Candles</h4>
                        <div id="heikin-ashi-chart-selected" style="height: 300px;"></div>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label><input type="checkbox" id="showHeikinAshi-selected" checked onchange="toggleHeikinAshi('selected')"> Show Heikin Ashi</label>
                        <label><input type="checkbox" id="showVolume-selected" checked> Show Volume</label>
                        <label><input type="checkbox" id="showSignals-selected" checked> Show Signals</label>
                    </div>
                    <div class="stochastic-controls">
                        <button class="stoch-button active" onclick="toggleStochastic('selected', 'stoch14')" data-stoch="stoch14" data-symbol="selected">Stoch14</button>
                        <button class="stoch-button active" onclick="toggleStochastic('selected', 'stoch20')" data-stoch="stoch20" data-symbol="selected">Stoch20</button>
                        <button class="stoch-button active" onclick="toggleStochastic('selected', 'stoch40')" data-stoch="stoch40" data-symbol="selected">Stoch40</button>
                        <button class="stoch-button active" onclick="toggleStochastic('selected', 'stoch60')" data-stoch="stoch60" data-symbol="selected">Stoch60</button>
                        <button class="stoch-button active" onclick="toggleStochastic('selected', 'stoch80')" data-stoch="stoch80" data-symbol="selected">Stoch80</button>
                        <button class="stoch-button active" onclick="toggleStochastic('selected', 'stoch100')" data-stoch="stoch100" data-symbol="selected">Stoch100</button>
                    </div>
                </div>
            `;
            
            symbolGrid.appendChild(symbolCard);
            
            // Find chart data for this symbol
            const symbolChartData = allChartData.find(data => data.symbol === symbol);
            if (symbolChartData && symbolChartData.data) {
                createChart(symbol, 'selected', [symbolChartData]);
            } else {
                // Show message in chart container if no data
                const chartContainer = document.getElementById('chart-selected');
                if (chartContainer) {
                    chartContainer.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-style: italic;">
                            Chart data not available for ${symbol}
                        </div>
                    `;
                }
            }
        }

        // Create individual chart with separate Heikin Ashi chart
        function createChart(symbol, index, allChartData) {
            // Validate input parameters
            if (!allChartData || !Array.isArray(allChartData)) {
                console.warn(`Invalid chart data array for symbol: ${symbol}`);
                return;
            }
            
            // Find chart data for this symbol
            const symbolData = allChartData.find(data => data && data.symbol === symbol);
            if (!symbolData || !symbolData.data || !Array.isArray(symbolData.data) || symbolData.data.length === 0) {
                console.warn(`No chart data found for symbol: ${symbol}`);
                const chartContainer = document.getElementById(`chart-${index}`);
                if (chartContainer) {
                    chartContainer.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-style: italic;">
                            No chart data available for ${symbol}
                        </div>
                    `;
                }
                return;
            }

            const chartContainer = document.getElementById(`chart-${index}`);
            const heikinAshiContainer = document.getElementById(`heikin-ashi-chart-${index}`);
            const stochasticContainer = document.getElementById(`stochastic-chart-${index}`);
            
            if (!chartContainer || !heikinAshiContainer || !stochasticContainer) {
                console.warn(`Chart containers not found for index: ${index}`);
                return;
            }

            // Validate LightweightCharts availability
            if (typeof LightweightCharts === 'undefined') {
                console.error('LightweightCharts library not loaded');
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #dc3545; font-style: italic;">
                        LightweightCharts library not loaded
                    </div>
                `;
                return;
            }
            
            // Create main chart
            const mainChart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 400,
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                timeScale: {
                    borderColor: '#cccccc',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: '#cccccc',
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.3,
                    },
                    priceFormat: {
                        type: 'price',
                        precision: 8,
                        minMove: 0.00000001,
                    },
                },
            });
            
            // Create Heikin Ashi chart
            const heikinAshiChart = LightweightCharts.createChart(heikinAshiContainer, {
                width: heikinAshiContainer.clientWidth,
                height: 300,
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                timeScale: {
                    borderColor: '#cccccc',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: '#cccccc',
                    priceFormat: {
                        type: 'price',
                        precision: 8,
                        minMove: 0.00000001,
                    },
                },
            });
            
            // Create Stochastic chart
            const stochasticChart = LightweightCharts.createChart(stochasticContainer, {
                width: stochasticContainer.clientWidth,
                height: 250,
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                timeScale: {
                    borderColor: '#cccccc',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: '#cccccc',
                    priceFormat: {
                        type: 'price',
                        precision: 2,
                        minMove: 0.01,
                    },
                },
            });
            
            // Validate chart creation
            if (!mainChart || !heikinAshiChart || !stochasticChart || typeof mainChart.addCandlestickSeries !== 'function') {
                console.error('Chart creation failed');
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #dc3545; font-style: italic;">
                        Chart creation failed
                    </div>
                `;
                return;
            }

            // Process chart data
            const regularCandleData = [];
            const heikinAshiCandleData = [];
            const stochasticData = {
                k: [],
                d: [],
                stoch14: { k: [], d: [] },
                stoch20: { k: [], d: [] },
                stoch40: { k: [], d: [] },
                stoch60: { k: [], d: [] },
                stoch80: { k: [], d: [] },
                stoch100: { k: [], d: [] }
            };
            const volumeData = [];
            const markers = [];
            const candleDetails = {}; // For tooltip data

            symbolData.data.forEach((item, itemIndex) => {
                try {
                    const candle = item.candle;
                    const haCandle = item.heikin_ashi;
                    const signal = item.signal;
                    const stochastic = item.stochastic;

                    if (!candle || !candle.timestamp) {
                        console.warn(`Invalid candle data at index ${itemIndex} for symbol ${symbol}`);
                        return;
                    }

                    const time = Math.floor(new Date(candle.timestamp).getTime() / 1000);
                    
                    // Validate that we got a valid timestamp
                    if (isNaN(time) || time <= 0) {
                        console.warn(`Invalid timestamp in candle data at index ${itemIndex} for symbol ${symbol}: ${candle.timestamp}`);
                        return;
                    }

                    // Store candle details for tooltip
                    candleDetails[time] = {
                        date: new Date(candle.timestamp).toLocaleString(),
                        candle: candle,
                        heikinAshi: haCandle,
                        stochastic: stochastic || null,
                        signal: signal,
                        balance: item.balance || 0,
                        equity: item.equity || 0,
                        activeTrade: item.active_trade || false,
                        tradeInfo: item.trade_info || null
                    };

                    regularCandleData.push({
                        time: time,
                        open: parseFloat(candle.open),
                        high: parseFloat(candle.high),
                        low: parseFloat(candle.low),
                        close: parseFloat(candle.close),
                    });

                    if (haCandle && haCandle.open) {
                        heikinAshiCandleData.push({
                            time: time,
                            open: parseFloat(haCandle.open),
                            high: parseFloat(haCandle.high),
                            low: parseFloat(haCandle.low),
                            close: parseFloat(haCandle.close),
                        });
                    }
                    
                    // Add Stochastic data
                    const multiStochastic = item.multi_stochastic;
                    
                    if (multiStochastic) {
                        // Initialize stochastic data structure if not exists
                        if (!stochasticData.stoch14) stochasticData.stoch14 = { k: [], d: [] };
                        if (!stochasticData.stoch20) stochasticData.stoch20 = { k: [], d: [] };
                        if (!stochasticData.stoch40) stochasticData.stoch40 = { k: [], d: [] };
                        if (!stochasticData.stoch60) stochasticData.stoch60 = { k: [], d: [] };
                        if (!stochasticData.stoch80) stochasticData.stoch80 = { k: [], d: [] };
                        if (!stochasticData.stoch100) stochasticData.stoch100 = { k: [], d: [] };
                        
                        // Process all 6 stochastics
                        const stochTypes = ['stoch14', 'stoch20', 'stoch40', 'stoch60', 'stoch80', 'stoch100'];
                        
                        stochTypes.forEach(stochType => {
                            if (multiStochastic[stochType] && 
                                typeof multiStochastic[stochType].k === 'number' && 
                                typeof multiStochastic[stochType].d === 'number') {
                                
                                stochasticData[stochType].k.push({
                                    time: time,
                                    value: parseFloat(multiStochastic[stochType].k),
                                });
                                stochasticData[stochType].d.push({
                                    time: time,
                                    value: parseFloat(multiStochastic[stochType].d),
                                });
                            }
                        });
                    } else if (stochastic && typeof stochastic.k === 'number' && typeof stochastic.d === 'number') {
                        // Fallback to single stochastic
                        if (!stochasticData.k) stochasticData.k = [];
                        if (!stochasticData.d) stochasticData.d = [];
                        
                        stochasticData.k.push({
                            time: time,
                            value: parseFloat(stochastic.k),
                        });
                        stochasticData.d.push({
                            time: time,
                            value: parseFloat(stochastic.d),
                        });
                    }

                    volumeData.push({
                        time: time,
                        value: parseFloat(candle.volume || 0),
                        color: candle.close >= candle.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)',
                    });

                    // Add signal markers
                    if (signal && signal.position !== undefined && signal.position !== 0) {
                        let shape, color, text, position;

                        if (signal.position === 1) { // Long bullish
                            shape = 'arrowUp';
                            color = '#26a69a';
                            text = 'L';
                            position = 'belowBar';
                        } else if (signal.position === -1) { // Short bearish
                            shape = 'arrowDown';
                            color = '#ef5350';
                            text = 'S';
                            position = 'aboveBar';
                        } else if (signal.position === -2) { // Short bullish
                            shape = 'arrowDown';
                            color = '#d7793b';
                            text = 'S*';
                            position = 'aboveBar';
                        } else if (signal.position === 2) { // Long bearish
                            shape = 'arrowUp';
                            color = '#127aaf';
                            text = 'L*';
                            position = 'belowBar';
                        }

                        if (shape) {
                            markers.push({
                                time: time,
                                position: position,
                                color: color,
                                shape: shape,
                                text: text,
                                size: 1,
                            });
                        }
                    }
                } catch (error) {
                    console.error(`Error processing candle data at index ${itemIndex} for symbol ${symbol}:`, error);
                }
            });

            // Add series to main chart
            const candlestickSeries = mainChart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });

            // Add volume series to main chart
            const volumeSeries = mainChart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                },
            });

            // Add Heikin Ashi series to separate chart
            const heikinAshiSeries = heikinAshiChart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: true,
                borderUpColor: '#1e7e64',
                borderDownColor: '#d32f2f',
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
                wickVisible: true,
            });
            
            // Add Multi-Stochastic series to Stochastic chart
            const stochastic14KSeries = stochasticChart.addLineSeries({
                color: '#FF0000', // Red
                lineWidth: 2,
                title: 'Stoch14 %K',
            });
            
            const stochastic14DSeries = stochasticChart.addLineSeries({
                color: '#FF6666', // Light Red
                lineWidth: 1,
                title: 'Stoch14 %D',
            });
            
            const stochastic20KSeries = stochasticChart.addLineSeries({
                color: '#0000FF', // Blue
                lineWidth: 2,
                title: 'Stoch20 %K',
            });
            
            const stochastic20DSeries = stochasticChart.addLineSeries({
                color: '#6666FF', // Light Blue
                lineWidth: 1,
                title: 'Stoch20 %D',
            });
            
            const stochastic40KSeries = stochasticChart.addLineSeries({
                color: '#FF8000', // Orange
                lineWidth: 2,
                title: 'Stoch40 %K',
            });
            
            const stochastic40DSeries = stochasticChart.addLineSeries({
                color: '#FFB366', // Light Orange
                lineWidth: 1,
                title: 'Stoch40 %D',
            });
            
            const stochastic60KSeries = stochasticChart.addLineSeries({
                color: '#8000FF', // Purple
                lineWidth: 2,
                title: 'Stoch60 %K',
            });
            
            const stochastic60DSeries = stochasticChart.addLineSeries({
                color: '#B366FF', // Light Purple
                lineWidth: 1,
                title: 'Stoch60 %D',
            });
            
            const stochastic80KSeries = stochasticChart.addLineSeries({
                color: '#FFD700', // Gold
                lineWidth: 2,
                title: 'Stoch80 %K',
            });
            
            const stochastic80DSeries = stochasticChart.addLineSeries({
                color: '#FFE55C', // Light Gold
                lineWidth: 1,
                title: 'Stoch80 %D',
            });
            
            const stochastic100KSeries = stochasticChart.addLineSeries({
                color: '#00FF00', // Green
                lineWidth: 2,
                title: 'Stoch100 %K',
            });
            
            const stochastic100DSeries = stochasticChart.addLineSeries({
                color: '#66FF66', // Light Green
                lineWidth: 1,
                title: 'Stoch100 %D',
            });
            
            // Add overbought/oversold lines to Stochastic chart
            const overboughtLine = stochasticChart.addLineSeries({
                color: '#787B86',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: 'Overbought (80)',
            });
            
            const oversoldLine = stochasticChart.addLineSeries({
                color: '#787B86',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: 'Oversold (20)',
            });

            // Set data
            candlestickSeries.setData(regularCandleData);
            candlestickSeries.setMarkers(markers);
            volumeSeries.setData(volumeData);
            heikinAshiSeries.setData(heikinAshiCandleData);
            
            // Set Multi-Stochastic data
            if (stochasticData.stoch14 && stochasticData.stoch14.k.length > 0) {
                // Set all 6 stochastics
                const seriesMap = {
                    stoch14: { k: stochastic14KSeries, d: stochastic14DSeries },
                    stoch20: { k: stochastic20KSeries, d: stochastic20DSeries },
                    stoch40: { k: stochastic40KSeries, d: stochastic40DSeries },
                    stoch60: { k: stochastic60KSeries, d: stochastic60DSeries },
                    stoch80: { k: stochastic80KSeries, d: stochastic80DSeries },
                    stoch100: { k: stochastic100KSeries, d: stochastic100DSeries }
                };
                
                // Store series references for toggle functionality
                stochasticSeries[symbol] = seriesMap;
                
                Object.keys(seriesMap).forEach(stochType => {
                    if (stochasticData[stochType] && stochasticData[stochType].k.length > 0) {
                        seriesMap[stochType].k.setData(stochasticData[stochType].k);
                        seriesMap[stochType].d.setData(stochasticData[stochType].d);
                    }
                });
                
                // Add overbought/oversold lines
                const timeRange = { from: stochasticData.stoch14.k[0].time, to: stochasticData.stoch14.k[stochasticData.stoch14.k.length - 1].time };
                overboughtLine.setData([
                    { time: timeRange.from, value: 80 },
                    { time: timeRange.to, value: 80 }
                ]);
                oversoldLine.setData([
                    { time: timeRange.from, value: 20 },
                    { time: timeRange.to, value: 20 }
                ]);
            } else if (stochasticData.k && stochasticData.k.length > 0) {
                // Fallback to single stochastic
                stochastic14KSeries.setData(stochasticData.k);
                stochastic14DSeries.setData(stochasticData.d);
                
                // Add overbought/oversold lines
                const timeRange = { from: stochasticData.k[0].time, to: stochasticData.k[stochasticData.k.length - 1].time };
                overboughtLine.setData([
                    { time: timeRange.from, value: 80 },
                    { time: timeRange.to, value: 80 }
                ]);
                oversoldLine.setData([
                    { time: timeRange.from, value: 20 },
                    { time: timeRange.to, value: 20 }
                ]);
            }

            // Synchronize time scales using compatible v4.1.3 API
            function syncCharts(sourceChart, targetChart) {
                sourceChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                    if (logicalRange) {
                        targetChart.timeScale().setVisibleLogicalRange(logicalRange);
                    }
                });
            }

            // Set up bidirectional synchronization
            syncCharts(mainChart, heikinAshiChart);
            syncCharts(heikinAshiChart, mainChart);
            syncCharts(mainChart, stochasticChart);
            syncCharts(stochasticChart, mainChart);
            syncCharts(heikinAshiChart, stochasticChart);
            syncCharts(stochasticChart, heikinAshiChart);

            // Add click event listeners for tooltip
            const tooltip = document.getElementById('tooltip');
            
            function setupChartClickHandler(chart, chartElement) {
                chart.subscribeClick((param) => {
                    showTooltip(param, chartElement, candleDetails, symbol);
                });
            }

            setupChartClickHandler(mainChart, chartContainer);
            setupChartClickHandler(heikinAshiChart, heikinAshiContainer);
            setupChartClickHandler(stochasticChart, stochasticContainer);

            // Store chart references
            charts[symbol] = {
                mainChart: mainChart,
                heikinAshiChart: heikinAshiChart,
                stochasticChart: stochasticChart,
                candlestickSeries: candlestickSeries,
                heikinAshiSeries: heikinAshiSeries,
                stochastic14KSeries: stochastic14KSeries,
                stochastic14DSeries: stochastic14DSeries,
                stochastic20KSeries: stochastic20KSeries,
                stochastic20DSeries: stochastic20DSeries,
                stochastic40KSeries: stochastic40KSeries,
                stochastic40DSeries: stochastic40DSeries,
                stochastic60KSeries: stochastic60KSeries,
                stochastic60DSeries: stochastic60DSeries,
                stochastic80KSeries: stochastic80KSeries,
                stochastic80DSeries: stochastic80DSeries,
                stochastic100KSeries: stochastic100KSeries,
                stochastic100DSeries: stochastic100DSeries,
                volumeSeries: volumeSeries,
                data: symbolData.data,
                results: symbolData.results,
                candleDetails: candleDetails,
                index: index  // Store the index for resize handling
            };

            // Fit content
            mainChart.timeScale().fitContent();
            heikinAshiChart.timeScale().fitContent();
        }

        // Populate all symbols performance table
        function populatePerformanceSummary() {
            const results = backtestData.results.results;
            
            // Calculate performances with full details
            const performances = Object.entries(results).map(([symbol, result]) => ({
                symbol: symbol,
                startingBalance: result.starting_balance,
                endingBalance: result.equity,
                pnl: result.equity - result.starting_balance,
                pnlPercentage: ((result.equity - result.starting_balance) / result.starting_balance) * 100,
                trades: result.trades,
                wins: result.wins,
                losses: result.losses,
                winRate: result.trades > 0 ? (result.wins / result.trades) * 100 : 0,
                maxDrawdown: result.max_drawdown,
                maxDrawdownPercentage: (result.max_drawdown / result.starting_balance) * 100,
                maxEquity: result.max_equity
            }));

            // Sort by PnL (descending)
            performances.sort((a, b) => b.pnl - a.pnl);

            // Calculate summary statistics
            const totalSymbols = performances.length;
            const profitableSymbols = performances.filter(p => p.pnl > 0).length;
            const totalPnL = performances.reduce((sum, p) => sum + p.pnl, 0);
            const avgPnL = totalPnL / totalSymbols;
            const totalTrades = performances.reduce((sum, p) => sum + p.trades, 0);
            const totalWins = performances.reduce((sum, p) => sum + p.wins, 0);
            const totalLosses = performances.reduce((sum, p) => sum + p.losses, 0);
            const overallWinRate = totalTrades > 0 ? (totalWins / totalTrades) * 100 : 0;
            const avgMaxDrawdown = performances.reduce((sum, p) => sum + p.maxDrawdown, 0) / totalSymbols;
            const bestPerformer = performances[0];
            const worstPerformer = performances[performances.length - 1];

            // Populate summary
            const summaryEl = document.getElementById('performance-summary');
            summaryEl.innerHTML = `
                <div class="summary-stat">
                    <div class="summary-stat-value">${totalSymbols}</div>
                    <div class="summary-stat-label">Total Symbols</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value">${profitableSymbols}</div>
                    <div class="summary-stat-label">Profitable Symbols</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value">${((profitableSymbols / totalSymbols) * 100).toFixed(1)}%</div>
                    <div class="summary-stat-label">Success Rate</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value ${getClass(totalPnL, 0)}">${formatCurrency(totalPnL)}</div>
                    <div class="summary-stat-label">Total PnL</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value ${getClass(avgPnL, 0)}">${formatCurrency(avgPnL)}</div>
                    <div class="summary-stat-label">Average PnL</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value">${overallWinRate.toFixed(1)}%</div>
                    <div class="summary-stat-label">Overall Win Rate</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value">${totalTrades}</div>
                    <div class="summary-stat-label">Total Trades</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value">${formatCurrency(avgMaxDrawdown)}</div>
                    <div class="summary-stat-label">Avg Max Drawdown</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value">${bestPerformer.symbol}</div>
                    <div class="summary-stat-label">Best Performer</div>
                </div>
                <div class="summary-stat">
                    <div class="summary-stat-value">${worstPerformer.symbol}</div>
                    <div class="summary-stat-label">Worst Performer</div>
                </div>
            `;

            // Populate the table
            const tbody = document.getElementById('all-symbols-tbody');
            tbody.innerHTML = performances.map((perf, index) => `
                <tr>
                    <td>${index + 1}</td>
                    <td>${perf.symbol}</td>
                    <td>${formatCurrency(perf.startingBalance)}</td>
                    <td>${formatCurrency(perf.endingBalance)}</td>
                    <td class="${getClass(perf.pnl, 0)}">${formatCurrency(perf.pnl)}</td>
                    <td class="${getClass(perf.pnlPercentage, 0)}">${perf.pnlPercentage.toFixed(2)}%</td>
                    <td>${perf.trades}</td>
                    <td>${perf.wins}</td>
                    <td>${perf.losses}</td>
                    <td>${perf.winRate.toFixed(2)}%</td>
                    <td class="negative">${formatCurrency(perf.maxDrawdown)}</td>
                    <td class="negative">${perf.maxDrawdownPercentage.toFixed(2)}%</td>
                    <td>${formatCurrency(perf.maxEquity)}</td>
                </tr>
            `).join('');
        }

        // Show tooltip function
        function showTooltip(param, chartElement, candleDetails, symbol) {
            const tooltip = document.getElementById('tooltip');
            
            if (!param.time) {
                tooltip.style.display = 'none';
                return;
            }
            
            const details = candleDetails[param.time];
            
            if (details) {
                // Position tooltip at the top of the page (fixed positioning)
                tooltip.style.display = 'block';
                tooltip.style.left = '20px';
                tooltip.style.top = '20px';
                tooltip.style.position = 'fixed';
                
                let html = '<table>';
                html += '<button class="close-btn" onclick="document.getElementById(\'tooltip\').style.display=\'none\'">×</button>';
                html += '<tr><th colspan="2" style="text-align:center;background:#e3f2fd;">[SYMBOL] ' + symbol + '</th></tr>';
                html += '<tr><th colspan="2" style="text-align:center;background:#e3f2fd;">[DATE] ' + details.date + '</th></tr>';
                
                // Regular candle data
                html += '<tr><th colspan="2" style="text-align:center;background:#f0f0f0;">[CANDLE] Regular Candle</th></tr>';
                html += '<tr><td>Open</td><td>' + details.candle.open.toFixed(8) + '</td></tr>';
                html += '<tr><td>High</td><td>' + details.candle.high.toFixed(8) + '</td></tr>';
                html += '<tr><td>Low</td><td>' + details.candle.low.toFixed(8) + '</td></tr>';
                html += '<tr><td>Close</td><td>' + details.candle.close.toFixed(8) + '</td></tr>';
                html += '<tr><td>Volume</td><td>' + details.candle.volume.toFixed(8) + '</td></tr>';
                
                // Additional candle statistics
                const range = details.candle.high - details.candle.low;
                const bodySize = Math.abs(details.candle.close - details.candle.open);
                const upperWick = details.candle.high - Math.max(details.candle.open, details.candle.close);
                const lowerWick = Math.min(details.candle.open, details.candle.close) - details.candle.low;
                const changePercent = details.candle.open !== 0 ? ((details.candle.close - details.candle.open) / details.candle.open * 100) : 0;
                
                html += '<tr><td>Range (H-L)</td><td>' + range.toFixed(8) + '</td></tr>';
                html += '<tr><td>Body Size</td><td>' + bodySize.toFixed(8) + '</td></tr>';
                html += '<tr><td>Upper Wick</td><td>' + upperWick.toFixed(8) + '</td></tr>';
                html += '<tr><td>Lower Wick</td><td>' + lowerWick.toFixed(8) + '</td></tr>';
                html += '<tr><td>Change %</td><td class="' + (changePercent >= 0 ? 'positive' : 'negative') + '">' + changePercent.toFixed(4) + '%</td></tr>';
                html += '<tr><td>Candle Type</td><td>' + (details.candle.close >= details.candle.open ? 'Bullish' : 'Bearish') + '</td></tr>';
                
                // Heikin Ashi candle data if available
                if (details.heikinAshi) {
                    html += '<tr><th colspan="2" style="text-align:center;background:#fff3e0;">[HA] Heikin Ashi Candle</th></tr>';
                    html += '<tr><td>HA Open</td><td>' + details.heikinAshi.open.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA High</td><td>' + details.heikinAshi.high.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Low</td><td>' + details.heikinAshi.low.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Close</td><td>' + details.heikinAshi.close.toFixed(8) + '</td></tr>';
                    
                    const haRange = details.heikinAshi.high - details.heikinAshi.low;
                    const haBodySize = Math.abs(details.heikinAshi.close - details.heikinAshi.open);
                    const haChangePercent = details.heikinAshi.open !== 0 ? ((details.heikinAshi.close - details.heikinAshi.open) / details.heikinAshi.open * 100) : 0;
                    
                    html += '<tr><td>HA Range</td><td>' + haRange.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Body Size</td><td>' + haBodySize.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Change %</td><td class="' + (haChangePercent >= 0 ? 'positive' : 'negative') + '">' + haChangePercent.toFixed(4) + '%</td></tr>';
                    html += '<tr><td>HA Type</td><td>' + (details.heikinAshi.close >= details.heikinAshi.open ? 'Bullish' : 'Bearish') + '</td></tr>';
                }
                
                // Multi-Stochastic data if available
                if (details.multiStochastic) {
                    html += '<tr><th colspan="2" style="text-align:center;background:#e3f2fd;">[MULTI-STOCH] Multi-Stochastic Oscillators</th></tr>';
                    
                    // Stoch14 (Red)
                    if (details.multiStochastic.stoch14) {
                        html += '<tr><td style="color:#FF0000;font-weight:bold;">Stoch14 %K</td><td>' + details.multiStochastic.stoch14.k.toFixed(2) + '</td></tr>';
                        html += '<tr><td style="color:#FF6666;">Stoch14 %D</td><td>' + details.multiStochastic.stoch14.d.toFixed(2) + '</td></tr>';
                    }
                    
                    // Stoch20 (Blue)
                    if (details.multiStochastic.stoch20) {
                        html += '<tr><td style="color:#0000FF;font-weight:bold;">Stoch20 %K</td><td>' + details.multiStochastic.stoch20.k.toFixed(2) + '</td></tr>';
                        html += '<tr><td style="color:#6666FF;">Stoch20 %D</td><td>' + details.multiStochastic.stoch20.d.toFixed(2) + '</td></tr>';
                    }
                    
                    // Stoch40 (Orange)
                    if (details.multiStochastic.stoch40) {
                        html += '<tr><td style="color:#FF8000;font-weight:bold;">Stoch40 %K</td><td>' + details.multiStochastic.stoch40.k.toFixed(2) + '</td></tr>';
                        html += '<tr><td style="color:#FFB366;">Stoch40 %D</td><td>' + details.multiStochastic.stoch40.d.toFixed(2) + '</td></tr>';
                    }
                    
                    // Stoch60 (Purple)
                    if (details.multiStochastic.stoch60) {
                        html += '<tr><td style="color:#8000FF;font-weight:bold;">Stoch60 %K</td><td>' + details.multiStochastic.stoch60.k.toFixed(2) + '</td></tr>';
                        html += '<tr><td style="color:#B366FF;">Stoch60 %D</td><td>' + details.multiStochastic.stoch60.d.toFixed(2) + '</td></tr>';
                    }
                    
                    // Stoch80 (Gold)
                    if (details.multiStochastic.stoch80) {
                        html += '<tr><td style="color:#FFD700;font-weight:bold;">Stoch80 %K</td><td>' + details.multiStochastic.stoch80.k.toFixed(2) + '</td></tr>';
                        html += '<tr><td style="color:#FFE55C;">Stoch80 %D</td><td>' + details.multiStochastic.stoch80.d.toFixed(2) + '</td></tr>';
                    }
                    
                    // Stoch100 (Green)
                    if (details.multiStochastic.stoch100) {
                        html += '<tr><td style="color:#00FF00;font-weight:bold;">Stoch100 %K</td><td>' + details.multiStochastic.stoch100.k.toFixed(2) + '</td></tr>';
                        html += '<tr><td style="color:#66FF66;">Stoch100 %D</td><td>' + details.multiStochastic.stoch100.d.toFixed(2) + '</td></tr>';
                    }
                } else if (details.stochastic) {
                    // Fallback to single stochastic
                    html += '<tr><th colspan="2" style="text-align:center;background:#e3f2fd;">[STOCH] Stochastic Oscillator</th></tr>';
                    html += '<tr><td>%K Value</td><td>' + details.stochastic.k.toFixed(2) + '</td></tr>';
                    html += '<tr><td>%D Value</td><td>' + details.stochastic.d.toFixed(2) + '</td></tr>';
                    
                    // Stochastic conditions
                    const kValue = details.stochastic.k;
                    const dValue = details.stochastic.d;
                    
                    if (kValue > 80 && dValue > 80) {
                        html += '<tr><td>Condition</td><td style="color: #ef5350; font-weight: bold;">[OVERBOUGHT] Overbought</td></tr>';
                    } else if (kValue < 20 && dValue < 20) {
                        html += '<tr><td>Condition</td><td style="color: #26a69a; font-weight: bold;">[OVERSOLD] Oversold</td></tr>';
                    } else {
                        html += '<tr><td>Condition</td><td style="color: #666;">[NEUTRAL] Neutral</td></tr>';
                    }
                    
                    if (kValue > dValue) {
                        html += '<tr><td>Signal</td><td style="color: #26a69a; font-weight: bold;">[BULLISH] %K > %D</td></tr>';
                    } else if (kValue < dValue) {
                        html += '<tr><td>Signal</td><td style="color: #ef5350; font-weight: bold;">[BEARISH] %K < %D</td></tr>';
                    } else {
                        html += '<tr><td>Signal</td><td style="color: #666;">[NEUTRAL] %K = %D</td></tr>';
                    }
                }
                
                // Account information
                html += '<tr><th colspan="2" style="text-align:center;background:#e8f5e8;">[ACCOUNT] Account Information</th></tr>';
                html += '<tr><td>Balance</td><td>$' + details.balance.toFixed(8) + '</td></tr>';
                html += '<tr><td>Equity</td><td>$' + details.equity.toFixed(8) + '</td></tr>';
                
                const accountChange = details.equity - details.balance;
                const accountChangePercent = details.balance !== 0 ? (accountChange / details.balance * 100) : 0;
                
                html += '<tr><td>P&L</td><td class="' + (accountChange >= 0 ? 'positive' : 'negative') + '">$' + accountChange.toFixed(8) + '</td></tr>';
                html += '<tr><td>P&L %</td><td class="' + (accountChangePercent >= 0 ? 'positive' : 'negative') + '">' + accountChangePercent.toFixed(4) + '%</td></tr>';
                
                if (details.activeTrade) {
                    html += '<tr><td>Active Trade</td><td style="color: #ff9800; font-weight: bold;">[YES] Yes</td></tr>';
                } else {
                    html += '<tr><td>Active Trade</td><td>[NO] No</td></tr>';
                }
                
                // Calculate time information
                const candleTime = new Date(details.date);
                const dayOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][candleTime.getDay()];
                html += '<tr><td>Day of Week</td><td>' + dayOfWeek + '</td></tr>';
                html += '<tr><td>Hour</td><td>' + candleTime.getHours().toString().padStart(2, '0') + ':' + candleTime.getMinutes().toString().padStart(2, '0') + '</td></tr>';
                
                // Signal information (if present)
                if (details.signal && details.signal.position !== 0) {
                    html += '<tr class="signal-row"><th colspan="2" style="text-align:center;background:#fff3cd;">[SIGNAL] Signal Information</th></tr>';
                    html += '<tr class="signal-row"><td>Position</td><td>';
                    if (details.signal.position === 1) {
                        html += '<span style="color: #26a69a; font-weight: bold;">[UP] LONG BULLISH</span>';
                    } else if (details.signal.position === -1) {
                        html += '<span style="color: #ef5350; font-weight: bold;">[DOWN] SHORT BEARISH</span>';
                    } else if (details.signal.position === 2) {
                        html += '<span style="color: #127aaf; font-weight: bold;">[UP] LONG BEARISH</span>';
                    } else if (details.signal.position === -2) {
                        html += '<span style="color: #d7793b; font-weight: bold;">[DOWN] SHORT BULLISH</span>';
                    } else {
                        html += '<span style="color: #666;">[HOLD] HOLD</span>';
                    }
                    html += '</td></tr>';
                    html += '<tr class="signal-row"><td>Reason</td><td>' + (details.signal.reason || 'N/A') + '</td></tr>';
                    html += '<tr class="signal-row"><td>Strategy</td><td>' + (details.signal.strategy_name || 'N/A') + '</td></tr>';
                    html += '<tr class="signal-row"><td>Signal Time</td><td>' + new Date(details.signal.time || details.date).toLocaleString() + '</td></tr>';
                    
                    if (details.signal.trigger_price !== undefined && details.signal.trigger_price !== null) {
                        html += '<tr class="signal-row"><td>Trigger Price</td><td>' + details.signal.trigger_price.toFixed(8) + '</td></tr>';
                        
                        // Calculate distance from current price
                        const priceDiff = details.candle.close - details.signal.trigger_price;
                        const priceDiffPercent = details.signal.trigger_price !== 0 ? (priceDiff / details.signal.trigger_price * 100) : 0;
                        html += '<tr class="signal-row"><td>Price Distance</td><td class="' + (priceDiff >= 0 ? 'positive' : 'negative') + '">' + priceDiff.toFixed(8) + '</td></tr>';
                        html += '<tr class="signal-row"><td>Price Distance %</td><td class="' + (priceDiffPercent >= 0 ? 'positive' : 'negative') + '">' + priceDiffPercent.toFixed(4) + '%</td></tr>';
                    }
                    
                    // Add signal strength/confidence if available
                    if (details.signal.confidence !== undefined) {
                        html += '<tr class="signal-row"><td>Confidence</td><td>' + (details.signal.confidence * 100).toFixed(2) + '%</td></tr>';
                    }
                    
                    // Signal position mapping
                    const positionMap = {
                        1: 'Long Bullish (1)',
                        '-1': 'Short Bearish (-1)', 
                        2: 'Long Bearish (2)',
                        '-2': 'Short Bullish (-2)',
                        0: 'Hold (0)'
                    };
                    html += '<tr class="signal-row"><td>Position Code</td><td>' + (positionMap[details.signal.position] || details.signal.position) + '</td></tr>';
                }
                
                // Trade information (if present)
                if (details.tradeInfo) {
                    html += '<tr class="trade-row"><th colspan="2" style="text-align:center;background:#d1ecf1;">[TRADE] Trade Information</th></tr>';
                    if (details.tradeInfo.entry && details.tradeInfo.entry > 0) {
                        html += '<tr class="trade-row"><td>Entry Price</td><td>' + details.tradeInfo.entry.toFixed(8) + '</td></tr>';
                        
                        if (details.tradeInfo.entry_time) {
                            html += '<tr class="trade-row"><td>Entry Time</td><td>' + new Date(details.tradeInfo.entry_time).toLocaleString() + '</td></tr>';
                        }
                        
                        html += '<tr class="trade-row"><td>Side</td><td>' + (details.tradeInfo.side || 'N/A') + '</td></tr>';
                        
                        if (details.tradeInfo.quantity) {
                            html += '<tr class="trade-row"><td>Quantity</td><td>' + details.tradeInfo.quantity.toFixed(8) + '</td></tr>';
                        }
                        
                        if (details.tradeInfo.cost) {
                            html += '<tr class="trade-row"><td>Cost</td><td>$' + details.tradeInfo.cost.toFixed(8) + '</td></tr>';
                        }
                        
                        if (details.tradeInfo.exit && details.tradeInfo.exit > 0) {
                            html += '<tr class="trade-row"><td>Exit Price</td><td>' + details.tradeInfo.exit.toFixed(8) + '</td></tr>';
                            
                            if (details.tradeInfo.exit_time) {
                                html += '<tr class="trade-row"><td>Exit Time</td><td>' + new Date(details.tradeInfo.exit_time).toLocaleString() + '</td></tr>';
                            }
                            
                            html += '<tr class="trade-row"><td>P&L</td><td class="' + (details.tradeInfo.pnl >= 0 ? 'positive' : 'negative') + '">$' + details.tradeInfo.pnl.toFixed(8) + '</td></tr>';
                            
                            // Calculate additional trade metrics
                            const priceDiff = details.tradeInfo.exit - details.tradeInfo.entry;
                            const returnPercent = details.tradeInfo.entry !== 0 ? (priceDiff / details.tradeInfo.entry * 100) : 0;
                            
                            if (details.tradeInfo.side === 'short') {
                                const adjustedReturn = -returnPercent; // Invert for short trades
                                html += '<tr class="trade-row"><td>Return %</td><td class="' + (adjustedReturn >= 0 ? 'positive' : 'negative') + '">' + adjustedReturn.toFixed(4) + '%</td></tr>';
                            } else {
                                html += '<tr class="trade-row"><td>Return %</td><td class="' + (returnPercent >= 0 ? 'positive' : 'negative') + '">' + returnPercent.toFixed(4) + '%</td></tr>';
                            }
                            
                            html += '<tr class="trade-row"><td>Exit Reason</td><td>' + (details.tradeInfo.reason || 'N/A') + '</td></tr>';
                            
                            // Trade duration if both times are available
                            if (details.tradeInfo.entry_time && details.tradeInfo.exit_time) {
                                const duration = new Date(details.tradeInfo.exit_time) - new Date(details.tradeInfo.entry_time);
                                const hours = Math.floor(duration / (1000 * 60 * 60));
                                const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
                                html += '<tr class="trade-row"><td>Duration</td><td>' + hours + 'h ' + minutes + 'm</td></tr>';
                            }
                        }
                        
                        // MAE and MFE if available
                        if (details.tradeInfo.mae !== undefined) {
                            html += '<tr class="trade-row"><td>MAE (Max Loss)</td><td class="negative">$' + details.tradeInfo.mae.toFixed(8) + '</td></tr>';
                        }
                        
                        if (details.tradeInfo.mfe !== undefined) {
                            html += '<tr class="trade-row"><td>MFE (Max Gain)</td><td class="positive">$' + details.tradeInfo.mfe.toFixed(8) + '</td></tr>';
                        }
                    }
                }
                
                html += '</table>';
                tooltip.innerHTML = html;
            }
        }

        // Toggle Heikin Ashi chart visibility
        function toggleHeikinAshi(index) {
            const checkbox = document.getElementById(`showHeikinAshi-${index}`);
            const container = document.getElementById(`heikin-ashi-container-${index}`);
            
            if (container) {
                container.style.display = checkbox.checked ? 'block' : 'none';
            }
        }

        // Toggle stochastic visibility
        function toggleStochastic(symbolIndex, stochType) {
            const button = document.querySelector(`[data-symbol="${symbolIndex}"][data-stoch="${stochType}"]`);
            const isActive = button.classList.contains('active');
            
            // Get the chart data for this symbol
            const symbol = Object.keys(charts).find(key => charts[key].index === symbolIndex);
            if (symbol && stochasticSeries[symbol]) {
                const seriesMap = stochasticSeries[symbol];
                
                if (seriesMap[stochType] && seriesMap[stochType].k && seriesMap[stochType].d) {
                    const kSeries = seriesMap[stochType].k;
                    const dSeries = seriesMap[stochType].d;
                    
                    // Check if setVisible method exists
                    if (typeof kSeries.setVisible === 'function' && typeof dSeries.setVisible === 'function') {
                        if (isActive) {
                            // Hide the stochastic
                            kSeries.setVisible(false);
                            dSeries.setVisible(false);
                            button.classList.remove('active');
                        } else {
                            // Show the stochastic
                            kSeries.setVisible(true);
                            dSeries.setVisible(true);
                            button.classList.add('active');
                        }
                    } else {
                        console.error('setVisible method not available on series for', stochType, 'in symbol', symbol);
                    }
                } else {
                    console.error('Series not found for', stochType, 'in symbol', symbol);
                }
            } else {
                console.error('Chart data not found for symbol index', symbolIndex);
            }
        }

        // Hide tooltip when clicking elsewhere
        document.addEventListener('click', (event) => {
            const tooltip = document.getElementById('tooltip');
            if (!tooltip.contains(event.target) && !event.target.closest('.chart-container')) {
                tooltip.style.display = 'none';
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            Object.values(charts).forEach(chartData => {
                if (chartData.mainChart && chartData.index !== undefined) {
                    const mainContainer = document.getElementById(`chart-${chartData.index}`);
                    if (mainContainer) {
                        chartData.mainChart.applyOptions({ 
                            width: mainContainer.clientWidth 
                        });
                    }
                }
                if (chartData.heikinAshiChart && chartData.index !== undefined) {
                    const haContainer = document.getElementById(`heikin-ashi-chart-${chartData.index}`);
                    if (haContainer) {
                        chartData.heikinAshiChart.applyOptions({ 
                            width: haContainer.clientWidth 
                        });
                    }
                }
                if (chartData.stochasticChart && chartData.index !== undefined) {
                    const stochasticContainer = document.getElementById(`stochastic-chart-${chartData.index}`);
                    if (stochasticContainer) {
                        chartData.stochasticChart.applyOptions({ 
                            width: stochasticContainer.clientWidth 
                        });
                    }
                }
            });
        });

        // Check if LightweightCharts is available
        function checkLibraryAvailability() {
            console.log('LightweightCharts available:', typeof LightweightCharts !== 'undefined');
            console.log('LightweightCharts object:', LightweightCharts);
            if (typeof LightweightCharts !== 'undefined') {
                console.log('createChart method:', typeof LightweightCharts.createChart);
            }
        }

        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            checkLibraryAvailability();
            loadData();
        });
    </script>
</body>
</html> 