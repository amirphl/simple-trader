<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Symbol Backtest Results</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #666;
        }
        .error {
            text-align: center;
            padding: 50px;
            color: #dc3545;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 5px;
            margin: 20px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        .positive { color: #28a745; }
        .negative { color: #dc3545; }
        .symbol-grid {
            display: flex;
            flex-direction: column;
            gap: 30px;
            padding: 30px;
        }
        .symbol-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }
        .symbol-header {
            background: #343a40;
            color: white;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.1em;
        }
        .symbol-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            padding: 20px;
            background: #f8f9fa;
        }
        .symbol-stat {
            text-align: center;
        }
        .symbol-stat-value {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .symbol-stat-label {
            font-size: 0.8em;
            color: #666;
        }
        .charts-container {
            padding: 20px;
        }
        .chart-container {
            margin-bottom: 20px;
        }
        .chart-container h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            text-align: center;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
        }
        .heikin-ashi-container {
            border-top: 2px solid #dee2e6;
            padding-top: 20px;
        }
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .control-group label {
            font-weight: 500;
        }
        .top-performers {
            padding: 30px;
            background: white;
        }
        .performers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        .performer-list {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }
        .performer-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #dee2e6;
        }
        .performer-item:last-child {
            border-bottom: none;
        }
        .refresh-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px;
        }
        .refresh-btn:hover {
            background: #0056b3;
        }
        
        /* Tooltip styles */
        .tooltip {
            position: fixed;
            background: #ffffff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            font-size: 13px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            z-index: 10000;
            display: none;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
            left: 20px !important;
            top: 20px !important;
        }
        .tooltip table {
            width: 100%;
            border-collapse: collapse;
        }
        .tooltip th, .tooltip td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .tooltip th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        .tooltip .close-btn {
            position: absolute;
            top: 5px;
            right: 8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Multi-Symbol Backtest Results</h1>
            <div id="strategy-info"></div>
        </div>
        
        <button class="refresh-btn" onclick="loadData()">Refresh Data</button>
        
        <div id="loading" class="loading">
            Loading backtest data...
        </div>
        
        <div id="error-message" class="error" style="display: none;">
        </div>
        
        <div id="content" style="display: none;">
            <div id="stats-grid" class="stats-grid">
                <!-- Stats will be populated here -->
            </div>
            
            <div id="symbol-grid" class="symbol-grid">
                <!-- Symbol charts will be populated here -->
            </div>
            
            <div class="top-performers">
                <h2>Performance Summary</h2>
                <div class="performers-grid">
                    <div>
                        <h3>Top 10 Performers</h3>
                        <div id="top-performers" class="performer-list">
                            <!-- Top performers will be populated here -->
                        </div>
                    </div>
                    <div>
                        <h3>Bottom 5 Performers</h3>
                        <div id="bottom-performers" class="performer-list">
                            <!-- Bottom performers will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip for candle details -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        let backtestData = null;
        let charts = {};

        // Helper function to get CSS class based on value comparison
        function getClass(value, threshold) {
            return value >= threshold ? 'positive' : 'negative';
        }

        // Helper function to format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', { 
                style: 'currency', 
                currency: 'USD' 
            }).format(value);
        }

        // Helper function to format percentage
        function formatPercentage(value) {
            return (value * 100).toFixed(2) + '%';
        }

        // Load data from JSON file
        async function loadData() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error-message');
            const contentEl = document.getElementById('content');
            
            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            contentEl.style.display = 'none';

            try {
                const response = await fetch('multi_symbol_backtest_data.json?' + Date.now()); // Cache busting
                if (!response.ok) {
                    throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);
                }
                
                backtestData = await response.json();
                console.log('Loaded backtest data:', backtestData);
                
                // Validate the structure of loaded data
                if (!backtestData || typeof backtestData !== 'object') {
                    throw new Error('Invalid JSON structure: root object is missing');
                }
                
                if (!backtestData.results) {
                    throw new Error('Invalid JSON structure: "results" property is missing');
                }
                
                if (!backtestData.results.results) {
                    throw new Error('Invalid JSON structure: "results.results" property is missing');
                }
                
                console.log('Chart data loaded - symbols:', backtestData.chartData ? backtestData.chartData.length : 0);
                
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';
                
                // Populate the UI
                populateHeader();
                populateStats();
                populateSymbolCharts();
                populatePerformanceSummary();
                
            } catch (error) {
                console.error('Error loading data:', error);
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
                errorEl.innerHTML = `
                    <h3>Failed to Load Data</h3>
                    <p>${error.message}</p>
                    <p>Please ensure the <code>multi_symbol_backtest_data.json</code> file exists and run the backtest to generate it.</p>
                    <button onclick="loadData()" style="margin-top: 10px; padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Retry</button>
                `;
            }
        }

        // Populate header information
        function populateHeader() {
            const results = backtestData.results;
            const strategyInfo = document.getElementById('strategy-info');
            
            const startTime = new Date(results.start_time).toLocaleDateString();
            const endTime = new Date(results.end_time).toLocaleDateString();
            const duration = Math.round((new Date(results.end_time) - new Date(results.start_time)) / (1000 * 60 * 60)); // hours
            
            strategyInfo.innerHTML = `
                <h2>${results.strategy} Strategy</h2>
                <p>Period: ${startTime} to ${endTime} | Duration: ${duration}h</p>
            `;
        }

        // Populate statistics grid
        function populateStats() {
            const results = backtestData.results;
            const metrics = results.overall_metrics;
            const statsGrid = document.getElementById('stats-grid');
            
            const stats = [
                {
                    value: results.total_symbols,
                    label: 'Total Symbols',
                    class: ''
                },
                {
                    value: results.successful_runs,
                    label: 'Successful Runs',
                    class: ''
                },
                {
                    value: Math.round(metrics.total_trades || 0),
                    label: 'Total Trades',
                    class: ''
                },
                {
                    value: formatPercentage(metrics.overall_win_rate || 0),
                    label: 'Overall Win Rate',
                    class: getClass((metrics.overall_win_rate || 0) * 100, 50)
                },
                {
                    value: formatCurrency(metrics.total_pnl || 0),
                    label: 'Total P&L',
                    class: getClass(metrics.total_pnl || 0, 0)
                },
                {
                    value: formatCurrency(metrics.avg_pnl_per_symbol || 0),
                    label: 'Avg P&L per Symbol',
                    class: getClass(metrics.avg_pnl_per_symbol || 0, 0)
                },
                {
                    value: `${Math.round(metrics.profitable_symbols_count || 0)}/${results.successful_runs}`,
                    label: 'Profitable Symbols',
                    class: ''
                },
                {
                    value: formatPercentage(metrics.profitable_symbols_ratio || 0),
                    label: 'Success Rate',
                    class: getClass((metrics.profitable_symbols_ratio || 0) * 100, 50)
                }
            ];

            statsGrid.innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-value ${stat.class}">${stat.value}</div>
                    <div class="stat-label">${stat.label}</div>
                </div>
            `).join('');
        }

        // Populate symbol charts
        function populateSymbolCharts() {
            const results = backtestData.results.results;
            const chartData = backtestData.chartData;
            const symbolGrid = document.getElementById('symbol-grid');
            
            // Check if we have valid data
            if (!results || typeof results !== 'object') {
                console.error('No valid results data found');
                return;
            }
            
            if (!chartData || !Array.isArray(chartData)) {
                console.warn('No chart data available, charts will not be displayed');
            }
            
            let symbolIndex = 0;
            symbolGrid.innerHTML = '';
            
            for (const [symbol, result] of Object.entries(results)) {
                const pnl = result.equity - result.starting_balance;
                const winRate = result.trades > 0 ? (result.wins / result.trades) * 100 : 0;
                
                const symbolCard = document.createElement('div');
                symbolCard.className = 'symbol-card';
                symbolCard.innerHTML = `
                    <div class="symbol-header">${symbol}</div>
                    <div class="symbol-stats">
                        <div class="symbol-stat">
                            <div class="symbol-stat-value ${getClass(pnl, 0)}">${formatCurrency(pnl)}</div>
                            <div class="symbol-stat-label">P&L</div>
                        </div>
                        <div class="symbol-stat">
                            <div class="symbol-stat-value">${result.trades}</div>
                            <div class="symbol-stat-label">Trades</div>
                        </div>
                        <div class="symbol-stat">
                            <div class="symbol-stat-value ${getClass(winRate, 50)}">${winRate.toFixed(1)}%</div>
                            <div class="symbol-stat-label">Win Rate</div>
                        </div>
                    </div>
                    <div class="charts-container">
                        <div class="chart-container">
                            <h4>Regular Candles</h4>
                            <div id="chart-${symbolIndex}" style="height: 400px;"></div>
                        </div>
                        <div class="chart-container heikin-ashi-container" id="heikin-ashi-container-${symbolIndex}">
                            <h4>Heikin Ashi Candles</h4>
                            <div id="heikin-ashi-chart-${symbolIndex}" style="height: 300px;"></div>
                        </div>
                    </div>
                    <div class="controls">
                        <div class="control-group">
                            <label><input type="checkbox" id="showHeikinAshi-${symbolIndex}" checked onchange="toggleHeikinAshi(${symbolIndex})"> Show Heikin Ashi</label>
                            <label><input type="checkbox" id="showVolume-${symbolIndex}" checked> Show Volume</label>
                            <label><input type="checkbox" id="showSignals-${symbolIndex}" checked> Show Signals</label>
                        </div>
                    </div>
                `;
                
                symbolGrid.appendChild(symbolCard);
                
                // Create chart for this symbol only if chart data is available
                if (chartData && Array.isArray(chartData)) {
                    createChart(symbol, symbolIndex, chartData);
                } else {
                    // Show message in chart container if no data
                    const chartContainer = document.getElementById(`chart-${symbolIndex}`);
                    if (chartContainer) {
                        chartContainer.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-style: italic;">
                                Chart data not available for ${symbol}
                            </div>
                        `;
                    }
                }
                symbolIndex++;
            }
        }

        // Create individual chart with separate Heikin Ashi chart
        function createChart(symbol, index, allChartData) {
            // Validate input parameters
            if (!allChartData || !Array.isArray(allChartData)) {
                console.warn(`Invalid chart data array for symbol: ${symbol}`);
                return;
            }
            
            // Find chart data for this symbol
            const symbolData = allChartData.find(data => data && data.symbol === symbol);
            if (!symbolData || !symbolData.data || !Array.isArray(symbolData.data) || symbolData.data.length === 0) {
                console.warn(`No chart data found for symbol: ${symbol}`);
                const chartContainer = document.getElementById(`chart-${index}`);
                if (chartContainer) {
                    chartContainer.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-style: italic;">
                            No chart data available for ${symbol}
                        </div>
                    `;
                }
                return;
            }

            const chartContainer = document.getElementById(`chart-${index}`);
            const heikinAshiContainer = document.getElementById(`heikin-ashi-chart-${index}`);
            
            if (!chartContainer || !heikinAshiContainer) {
                console.warn(`Chart containers not found for index: ${index}`);
                return;
            }

            // Validate LightweightCharts availability
            if (typeof LightweightCharts === 'undefined') {
                console.error('LightweightCharts library not loaded');
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #dc3545; font-style: italic;">
                        LightweightCharts library not loaded
                    </div>
                `;
                return;
            }
            
            // Create main chart
            const mainChart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 400,
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                timeScale: {
                    borderColor: '#cccccc',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: '#cccccc',
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.3,
                    },
                    priceFormat: {
                        type: 'price',
                        precision: 8,
                        minMove: 0.00000001,
                    },
                },
            });
            
            // Create Heikin Ashi chart
            const heikinAshiChart = LightweightCharts.createChart(heikinAshiContainer, {
                width: heikinAshiContainer.clientWidth,
                height: 300,
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                timeScale: {
                    borderColor: '#cccccc',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: '#cccccc',
                    priceFormat: {
                        type: 'price',
                        precision: 8,
                        minMove: 0.00000001,
                    },
                },
            });
            
            // Validate chart creation
            if (!mainChart || !heikinAshiChart || typeof mainChart.addCandlestickSeries !== 'function') {
                console.error('Chart creation failed');
                chartContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #dc3545; font-style: italic;">
                        Chart creation failed
                    </div>
                `;
                return;
            }

            // Process chart data
            const regularCandleData = [];
            const heikinAshiCandleData = [];
            const volumeData = [];
            const markers = [];
            const candleDetails = {}; // For tooltip data

            symbolData.data.forEach((item, itemIndex) => {
                try {
                    const candle = item.candle;
                    const haCandle = item.heikin_ashi;
                    const signal = item.signal;

                    if (!candle || !candle.timestamp) {
                        console.warn(`Invalid candle data at index ${itemIndex} for symbol ${symbol}`);
                        return;
                    }

                    const time = Math.floor(new Date(candle.timestamp).getTime() / 1000);
                    
                    // Validate that we got a valid timestamp
                    if (isNaN(time) || time <= 0) {
                        console.warn(`Invalid timestamp in candle data at index ${itemIndex} for symbol ${symbol}: ${candle.timestamp}`);
                        return;
                    }

                    // Store candle details for tooltip
                    candleDetails[time] = {
                        date: new Date(candle.timestamp).toLocaleString(),
                        candle: candle,
                        heikinAshi: haCandle,
                        signal: signal,
                        balance: item.balance || 0,
                        equity: item.equity || 0,
                        activeTrade: item.active_trade || false,
                        tradeInfo: item.trade_info || null
                    };

                    regularCandleData.push({
                        time: time,
                        open: parseFloat(candle.open),
                        high: parseFloat(candle.high),
                        low: parseFloat(candle.low),
                        close: parseFloat(candle.close),
                    });

                    if (haCandle && haCandle.open) {
                        heikinAshiCandleData.push({
                            time: time,
                            open: parseFloat(haCandle.open),
                            high: parseFloat(haCandle.high),
                            low: parseFloat(haCandle.low),
                            close: parseFloat(haCandle.close),
                        });
                    }

                    volumeData.push({
                        time: time,
                        value: parseFloat(candle.volume || 0),
                        color: candle.close >= candle.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)',
                    });

                    // Add signal markers
                    if (signal && signal.position !== undefined && signal.position !== 0) {
                        let shape, color, text, position;

                        if (signal.position === 1) { // Long bullish
                            shape = 'arrowUp';
                            color = '#26a69a';
                            text = 'L';
                            position = 'belowBar';
                        } else if (signal.position === -1) { // Short bearish
                            shape = 'arrowDown';
                            color = '#ef5350';
                            text = 'S';
                            position = 'aboveBar';
                        } else if (signal.position === -2) { // Short bullish
                            shape = 'arrowDown';
                            color = '#d7793b';
                            text = 'S*';
                            position = 'aboveBar';
                        } else if (signal.position === 2) { // Long bearish
                            shape = 'arrowUp';
                            color = '#127aaf';
                            text = 'L*';
                            position = 'belowBar';
                        }

                        if (shape) {
                            markers.push({
                                time: time,
                                position: position,
                                color: color,
                                shape: shape,
                                text: text,
                                size: 1,
                            });
                        }
                    }
                } catch (error) {
                    console.error(`Error processing candle data at index ${itemIndex} for symbol ${symbol}:`, error);
                }
            });

            // Add series to main chart
            const candlestickSeries = mainChart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });

            // Add volume series to main chart
            const volumeSeries = mainChart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                },
            });

            // Add Heikin Ashi series to separate chart
            const heikinAshiSeries = heikinAshiChart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: true,
                borderUpColor: '#1e7e64',
                borderDownColor: '#d32f2f',
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
                wickVisible: true,
            });

            // Set data
            candlestickSeries.setData(regularCandleData);
            candlestickSeries.setMarkers(markers);
            volumeSeries.setData(volumeData);
            heikinAshiSeries.setData(heikinAshiCandleData);

            // Synchronize time scales using compatible v4.1.3 API
            function syncCharts(sourceChart, targetChart) {
                sourceChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                    if (logicalRange) {
                        targetChart.timeScale().setVisibleLogicalRange(logicalRange);
                    }
                });
            }

            // Set up bidirectional synchronization
            syncCharts(mainChart, heikinAshiChart);
            syncCharts(heikinAshiChart, mainChart);

            // Add click event listeners for tooltip
            const tooltip = document.getElementById('tooltip');
            
            function setupChartClickHandler(chart, chartElement) {
                chart.subscribeClick((param) => {
                    showTooltip(param, chartElement, candleDetails, symbol);
                });
            }

            setupChartClickHandler(mainChart, chartContainer);
            setupChartClickHandler(heikinAshiChart, heikinAshiContainer);

            // Store chart references
            charts[symbol] = {
                mainChart: mainChart,
                heikinAshiChart: heikinAshiChart,
                candlestickSeries: candlestickSeries,
                heikinAshiSeries: heikinAshiSeries,
                volumeSeries: volumeSeries,
                data: symbolData.data,
                results: symbolData.results,
                candleDetails: candleDetails,
                index: index  // Store the index for resize handling
            };

            // Fit content
            mainChart.timeScale().fitContent();
            heikinAshiChart.timeScale().fitContent();
        }

        // Populate performance summary
        function populatePerformanceSummary() {
            const results = backtestData.results.results;
            
            // Calculate performances
            const performances = Object.entries(results).map(([symbol, result]) => ({
                symbol: symbol,
                pnl: result.equity - result.starting_balance
            }));

            // Sort by PnL
            performances.sort((a, b) => b.pnl - a.pnl);

            // Top 10 performers
            const topPerformers = document.getElementById('top-performers');
            const top10 = performances.slice(0, 10);
            topPerformers.innerHTML = top10.map((perf, index) => `
                <div class="performer-item">
                    <span>${index + 1}. ${perf.symbol}</span>
                    <span class="${getClass(perf.pnl, 0)}">${formatCurrency(perf.pnl)}</span>
                </div>
            `).join('');

            // Bottom 5 performers
            const bottomPerformers = document.getElementById('bottom-performers');
            const bottom5 = performances.slice(-5);
            bottomPerformers.innerHTML = bottom5.map((perf, index) => `
                <div class="performer-item">
                    <span>${performances.length - bottom5.length + index + 1}. ${perf.symbol}</span>
                    <span class="${getClass(perf.pnl, 0)}">${formatCurrency(perf.pnl)}</span>
                </div>
            `).join('');
        }

        // Show tooltip function
        function showTooltip(param, chartElement, candleDetails, symbol) {
            const tooltip = document.getElementById('tooltip');
            
            if (!param.time) {
                tooltip.style.display = 'none';
                return;
            }
            
            const details = candleDetails[param.time];
            
            if (details) {
                // Position tooltip at the top of the page (fixed positioning)
                tooltip.style.display = 'block';
                tooltip.style.left = '20px';
                tooltip.style.top = '20px';
                tooltip.style.position = 'fixed';
                
                let html = '<table>';
                html += '<button class="close-btn" onclick="document.getElementById(\'tooltip\').style.display=\'none\'">Ã—</button>';
                html += '<tr><th colspan="2" style="text-align:center;background:#e3f2fd;">[SYMBOL] ' + symbol + '</th></tr>';
                html += '<tr><th colspan="2" style="text-align:center;background:#e3f2fd;">[DATE] ' + details.date + '</th></tr>';
                
                // Regular candle data
                html += '<tr><th colspan="2" style="text-align:center;background:#f0f0f0;">[CANDLE] Regular Candle</th></tr>';
                html += '<tr><td>Open</td><td>' + details.candle.open.toFixed(8) + '</td></tr>';
                html += '<tr><td>High</td><td>' + details.candle.high.toFixed(8) + '</td></tr>';
                html += '<tr><td>Low</td><td>' + details.candle.low.toFixed(8) + '</td></tr>';
                html += '<tr><td>Close</td><td>' + details.candle.close.toFixed(8) + '</td></tr>';
                html += '<tr><td>Volume</td><td>' + details.candle.volume.toFixed(8) + '</td></tr>';
                
                // Additional candle statistics
                const range = details.candle.high - details.candle.low;
                const bodySize = Math.abs(details.candle.close - details.candle.open);
                const upperWick = details.candle.high - Math.max(details.candle.open, details.candle.close);
                const lowerWick = Math.min(details.candle.open, details.candle.close) - details.candle.low;
                const changePercent = details.candle.open !== 0 ? ((details.candle.close - details.candle.open) / details.candle.open * 100) : 0;
                
                html += '<tr><td>Range (H-L)</td><td>' + range.toFixed(8) + '</td></tr>';
                html += '<tr><td>Body Size</td><td>' + bodySize.toFixed(8) + '</td></tr>';
                html += '<tr><td>Upper Wick</td><td>' + upperWick.toFixed(8) + '</td></tr>';
                html += '<tr><td>Lower Wick</td><td>' + lowerWick.toFixed(8) + '</td></tr>';
                html += '<tr><td>Change %</td><td class="' + (changePercent >= 0 ? 'positive' : 'negative') + '">' + changePercent.toFixed(4) + '%</td></tr>';
                html += '<tr><td>Candle Type</td><td>' + (details.candle.close >= details.candle.open ? 'Bullish' : 'Bearish') + '</td></tr>';
                
                // Heikin Ashi candle data if available
                if (details.heikinAshi) {
                    html += '<tr><th colspan="2" style="text-align:center;background:#fff3e0;">[HA] Heikin Ashi Candle</th></tr>';
                    html += '<tr><td>HA Open</td><td>' + details.heikinAshi.open.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA High</td><td>' + details.heikinAshi.high.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Low</td><td>' + details.heikinAshi.low.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Close</td><td>' + details.heikinAshi.close.toFixed(8) + '</td></tr>';
                    
                    const haRange = details.heikinAshi.high - details.heikinAshi.low;
                    const haBodySize = Math.abs(details.heikinAshi.close - details.heikinAshi.open);
                    const haChangePercent = details.heikinAshi.open !== 0 ? ((details.heikinAshi.close - details.heikinAshi.open) / details.heikinAshi.open * 100) : 0;
                    
                    html += '<tr><td>HA Range</td><td>' + haRange.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Body Size</td><td>' + haBodySize.toFixed(8) + '</td></tr>';
                    html += '<tr><td>HA Change %</td><td class="' + (haChangePercent >= 0 ? 'positive' : 'negative') + '">' + haChangePercent.toFixed(4) + '%</td></tr>';
                    html += '<tr><td>HA Type</td><td>' + (details.heikinAshi.close >= details.heikinAshi.open ? 'Bullish' : 'Bearish') + '</td></tr>';
                }
                
                // Account information
                html += '<tr><th colspan="2" style="text-align:center;background:#e8f5e8;">[ACCOUNT] Account Information</th></tr>';
                html += '<tr><td>Balance</td><td>$' + details.balance.toFixed(8) + '</td></tr>';
                html += '<tr><td>Equity</td><td>$' + details.equity.toFixed(8) + '</td></tr>';
                
                const accountChange = details.equity - details.balance;
                const accountChangePercent = details.balance !== 0 ? (accountChange / details.balance * 100) : 0;
                
                html += '<tr><td>P&L</td><td class="' + (accountChange >= 0 ? 'positive' : 'negative') + '">$' + accountChange.toFixed(8) + '</td></tr>';
                html += '<tr><td>P&L %</td><td class="' + (accountChangePercent >= 0 ? 'positive' : 'negative') + '">' + accountChangePercent.toFixed(4) + '%</td></tr>';
                
                if (details.activeTrade) {
                    html += '<tr><td>Active Trade</td><td style="color: #ff9800; font-weight: bold;">[YES] Yes</td></tr>';
                } else {
                    html += '<tr><td>Active Trade</td><td>[NO] No</td></tr>';
                }
                
                // Calculate time information
                const candleTime = new Date(details.date);
                const dayOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][candleTime.getDay()];
                html += '<tr><td>Day of Week</td><td>' + dayOfWeek + '</td></tr>';
                html += '<tr><td>Hour</td><td>' + candleTime.getHours().toString().padStart(2, '0') + ':' + candleTime.getMinutes().toString().padStart(2, '0') + '</td></tr>';
                
                // Signal information (if present)
                if (details.signal && details.signal.position !== 0) {
                    html += '<tr class="signal-row"><th colspan="2" style="text-align:center;background:#fff3cd;">[SIGNAL] Signal Information</th></tr>';
                    html += '<tr class="signal-row"><td>Position</td><td>';
                    if (details.signal.position === 1) {
                        html += '<span style="color: #26a69a; font-weight: bold;">[UP] LONG BULLISH</span>';
                    } else if (details.signal.position === -1) {
                        html += '<span style="color: #ef5350; font-weight: bold;">[DOWN] SHORT BEARISH</span>';
                    } else if (details.signal.position === 2) {
                        html += '<span style="color: #127aaf; font-weight: bold;">[UP] LONG BEARISH</span>';
                    } else if (details.signal.position === -2) {
                        html += '<span style="color: #d7793b; font-weight: bold;">[DOWN] SHORT BULLISH</span>';
                    } else {
                        html += '<span style="color: #666;">[HOLD] HOLD</span>';
                    }
                    html += '</td></tr>';
                    html += '<tr class="signal-row"><td>Reason</td><td>' + (details.signal.reason || 'N/A') + '</td></tr>';
                    html += '<tr class="signal-row"><td>Strategy</td><td>' + (details.signal.strategy_name || 'N/A') + '</td></tr>';
                    html += '<tr class="signal-row"><td>Signal Time</td><td>' + new Date(details.signal.time || details.date).toLocaleString() + '</td></tr>';
                    
                    if (details.signal.trigger_price !== undefined && details.signal.trigger_price !== null) {
                        html += '<tr class="signal-row"><td>Trigger Price</td><td>' + details.signal.trigger_price.toFixed(8) + '</td></tr>';
                        
                        // Calculate distance from current price
                        const priceDiff = details.candle.close - details.signal.trigger_price;
                        const priceDiffPercent = details.signal.trigger_price !== 0 ? (priceDiff / details.signal.trigger_price * 100) : 0;
                        html += '<tr class="signal-row"><td>Price Distance</td><td class="' + (priceDiff >= 0 ? 'positive' : 'negative') + '">' + priceDiff.toFixed(8) + '</td></tr>';
                        html += '<tr class="signal-row"><td>Price Distance %</td><td class="' + (priceDiffPercent >= 0 ? 'positive' : 'negative') + '">' + priceDiffPercent.toFixed(4) + '%</td></tr>';
                    }
                    
                    // Add signal strength/confidence if available
                    if (details.signal.confidence !== undefined) {
                        html += '<tr class="signal-row"><td>Confidence</td><td>' + (details.signal.confidence * 100).toFixed(2) + '%</td></tr>';
                    }
                    
                    // Signal position mapping
                    const positionMap = {
                        1: 'Long Bullish (1)',
                        '-1': 'Short Bearish (-1)', 
                        2: 'Long Bearish (2)',
                        '-2': 'Short Bullish (-2)',
                        0: 'Hold (0)'
                    };
                    html += '<tr class="signal-row"><td>Position Code</td><td>' + (positionMap[details.signal.position] || details.signal.position) + '</td></tr>';
                }
                
                // Trade information (if present)
                if (details.tradeInfo) {
                    html += '<tr class="trade-row"><th colspan="2" style="text-align:center;background:#d1ecf1;">[TRADE] Trade Information</th></tr>';
                    if (details.tradeInfo.entry && details.tradeInfo.entry > 0) {
                        html += '<tr class="trade-row"><td>Entry Price</td><td>' + details.tradeInfo.entry.toFixed(8) + '</td></tr>';
                        
                        if (details.tradeInfo.entry_time) {
                            html += '<tr class="trade-row"><td>Entry Time</td><td>' + new Date(details.tradeInfo.entry_time).toLocaleString() + '</td></tr>';
                        }
                        
                        html += '<tr class="trade-row"><td>Side</td><td>' + (details.tradeInfo.side || 'N/A') + '</td></tr>';
                        
                        if (details.tradeInfo.quantity) {
                            html += '<tr class="trade-row"><td>Quantity</td><td>' + details.tradeInfo.quantity.toFixed(8) + '</td></tr>';
                        }
                        
                        if (details.tradeInfo.cost) {
                            html += '<tr class="trade-row"><td>Cost</td><td>$' + details.tradeInfo.cost.toFixed(8) + '</td></tr>';
                        }
                        
                        if (details.tradeInfo.exit && details.tradeInfo.exit > 0) {
                            html += '<tr class="trade-row"><td>Exit Price</td><td>' + details.tradeInfo.exit.toFixed(8) + '</td></tr>';
                            
                            if (details.tradeInfo.exit_time) {
                                html += '<tr class="trade-row"><td>Exit Time</td><td>' + new Date(details.tradeInfo.exit_time).toLocaleString() + '</td></tr>';
                            }
                            
                            html += '<tr class="trade-row"><td>P&L</td><td class="' + (details.tradeInfo.pnl >= 0 ? 'positive' : 'negative') + '">$' + details.tradeInfo.pnl.toFixed(8) + '</td></tr>';
                            
                            // Calculate additional trade metrics
                            const priceDiff = details.tradeInfo.exit - details.tradeInfo.entry;
                            const returnPercent = details.tradeInfo.entry !== 0 ? (priceDiff / details.tradeInfo.entry * 100) : 0;
                            
                            if (details.tradeInfo.side === 'short') {
                                const adjustedReturn = -returnPercent; // Invert for short trades
                                html += '<tr class="trade-row"><td>Return %</td><td class="' + (adjustedReturn >= 0 ? 'positive' : 'negative') + '">' + adjustedReturn.toFixed(4) + '%</td></tr>';
                            } else {
                                html += '<tr class="trade-row"><td>Return %</td><td class="' + (returnPercent >= 0 ? 'positive' : 'negative') + '">' + returnPercent.toFixed(4) + '%</td></tr>';
                            }
                            
                            html += '<tr class="trade-row"><td>Exit Reason</td><td>' + (details.tradeInfo.reason || 'N/A') + '</td></tr>';
                            
                            // Trade duration if both times are available
                            if (details.tradeInfo.entry_time && details.tradeInfo.exit_time) {
                                const duration = new Date(details.tradeInfo.exit_time) - new Date(details.tradeInfo.entry_time);
                                const hours = Math.floor(duration / (1000 * 60 * 60));
                                const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
                                html += '<tr class="trade-row"><td>Duration</td><td>' + hours + 'h ' + minutes + 'm</td></tr>';
                            }
                        }
                        
                        // MAE and MFE if available
                        if (details.tradeInfo.mae !== undefined) {
                            html += '<tr class="trade-row"><td>MAE (Max Loss)</td><td class="negative">$' + details.tradeInfo.mae.toFixed(8) + '</td></tr>';
                        }
                        
                        if (details.tradeInfo.mfe !== undefined) {
                            html += '<tr class="trade-row"><td>MFE (Max Gain)</td><td class="positive">$' + details.tradeInfo.mfe.toFixed(8) + '</td></tr>';
                        }
                    }
                }
                
                html += '</table>';
                tooltip.innerHTML = html;
            }
        }

        // Toggle Heikin Ashi chart visibility
        function toggleHeikinAshi(index) {
            const checkbox = document.getElementById(`showHeikinAshi-${index}`);
            const container = document.getElementById(`heikin-ashi-container-${index}`);
            
            if (container) {
                container.style.display = checkbox.checked ? 'block' : 'none';
            }
        }

        // Hide tooltip when clicking elsewhere
        document.addEventListener('click', (event) => {
            const tooltip = document.getElementById('tooltip');
            if (!tooltip.contains(event.target) && !event.target.closest('.chart-container')) {
                tooltip.style.display = 'none';
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            Object.values(charts).forEach(chartData => {
                if (chartData.mainChart && chartData.index !== undefined) {
                    const mainContainer = document.getElementById(`chart-${chartData.index}`);
                    if (mainContainer) {
                        chartData.mainChart.applyOptions({ 
                            width: mainContainer.clientWidth 
                        });
                    }
                }
                if (chartData.heikinAshiChart && chartData.index !== undefined) {
                    const haContainer = document.getElementById(`heikin-ashi-chart-${chartData.index}`);
                    if (haContainer) {
                        chartData.heikinAshiChart.applyOptions({ 
                            width: haContainer.clientWidth 
                        });
                    }
                }
            });
        });

        // Check if LightweightCharts is available
        function checkLibraryAvailability() {
            console.log('LightweightCharts available:', typeof LightweightCharts !== 'undefined');
            console.log('LightweightCharts object:', LightweightCharts);
            if (typeof LightweightCharts !== 'undefined') {
                console.log('createChart method:', typeof LightweightCharts.createChart);
            }
        }

        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            checkLibraryAvailability();
            loadData();
        });
    </script>
</body>
</html> 